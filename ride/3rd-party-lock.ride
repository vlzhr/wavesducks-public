{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func tryGetInteger(key: String) = {
  match getInteger(this, key) {
      case b:Int => b
      case _ => 0
  }
}

func tryGetString(key: String) = {
  match getString(this, key) {
      case a:String => a
      case _ => ""
  }
}

func keyBoughtBoosterLevel(addressStr: String) = "address_" + addressStr + "_boughtBoosterLevel"
func keyDuckUnlockTime(assetId: ByteVector) = "duck_" + assetId.toBase58String() + "_unlockTime"
func keyDuckOwner(assetId: ByteVector) = "duck_" + assetId.toBase58String() + "_owner"
func keySpotsBought(addressStr: String) = "address_" + addressStr + "_spotsBought"
func keySpotsBusy(addressStr: String) = "address_" + addressStr + "_spotsBusy"
func keyLockedDuckStatus(addressStr: String, assetIdStr: String) = "address_" + addressStr + "_lockedDuck_" + assetIdStr + "_status"

func getDuckDetails(assetId: ByteVector) = {
  let assetName = assetInfo(assetId).value().name.value()
  let assetNameParts = assetName.split("")
  let isJackpot = assetNameParts[assetNameParts.size() - 2] == "J"
  let assetColor = if isJackpot then "B" else assetNameParts[assetNameParts.size() - 1]
  (
    assetColor, isJackpot
  )
}

func getIncubatorAddress() = tryGetString("static_incubatorAddress").fromBase58String() #base58'3PEktVux2RhchSN63DsDo4b4mz4QqzKSeDv'
func getBreederAddress() = tryGetString("static_breederAddress").fromBase58String() #base58'3PDVuU45H7Eh5dmtNbnRNRStGwULA7NY6Hb'
func getFarmingAddress() = tryGetString("static_farmingAddress").fromBase58String() #base58'3PAETTtuW7aSiyKtn9GuML3RgtV1xdq1mQW'
func getEggAssetId() = tryGetString("static_eggAssetId").fromBase58String() #base58'C1iWsKGqLwjHUndiQ7iXpdmPum9PeCDFfyXBdJJosDRS'

func getAccessItemAssetId() = tryGetString("static_accessItemAssetId").fromBase58String()
func getAccessItemPrice() = tryGetInteger("static_accessItemPrice")
func getMinLockDuration() = tryGetInteger("static_minLockDuration")
func getBosterBuyAssetId() = tryGetString("static_boosterBuyAssetId").fromBase58String()

# DON'T USE tryGetInteger because it can return 0 as price for booster
func getBosterPriceForLevel(level: Int) = getInteger("static_boosterPriceLevel_" + level.toString()).valueOrErrorMessage("There is no price value for this level of booster")
func getBosterNameForLevel(level: Int) = getString("static_boosterName_" + level.toString()).valueOrErrorMessage("There is no suck booster")

@Callable(i)
func updateSetting(key: String, value: Int | String | Boolean | ByteVector) = {
  if (i.caller != this) then throw("Only administrator can call this method") else {
    match (value) {
        case int: Int => [IntegerEntry(key, int)]
        case s: String => [StringEntry(key, s)]
        case b: Boolean => [BooleanEntry(key, b)]
        case bv: ByteVector => [BinaryEntry(key, bv)]
        case _ => throw("Bad value type")
      }
  }
}

@Callable(i)
func deleteSetting(key: String) = {
    if (i.caller != this) then throw("Only administrator can call this method")
    else [DeleteEntry(key)]
}

@Callable(i)
func buyBooster() = {
  let kBoughtLevel = keyBoughtBoosterLevel(i.caller.toString())
  let boughtBoosterLevel = tryGetInteger(kBoughtLevel)
  let newLevel = boughtBoosterLevel + 1
  let pmt = i.payments[0].value()
  let price = getBosterPriceForLevel(newLevel)
  let expectedAssetId = getBosterBuyAssetId()
  if (pmt.amount != price) then throw("Bad price, it should be: " + price.toString()) else 
  if (pmt.assetId != expectedAssetId) then throw("Bad payment attached, it shoule be: " + expectedAssetId.toBase58String())
  else {
    let name = getBosterNameForLevel(newLevel)
    let boosterItem = Issue("RACE-" + name, "[Booster] Metarace booster for the game, level = " + newLevel.toString(), 1, 0, false)
    let boosterItemAssetId = boosterItem.calculateAssetId()
    [
      IntegerEntry(kBoughtLevel, newLevel),
      ScriptTransfer(i.caller, 1, boosterItemAssetId)
    ]
  }

}

@Callable(i)
func buyAccessItem() = {
  let pmt = i.payments[0].value()
  let addressStr = i.caller.toString()
  if (pmt.assetId != getAccessItemAssetId()) then {throw("Wrong asset attached")}
  else if (pmt.amount != getAccessItemPrice()) then {throw("Wrong amount of assets attached")}
  else {
    let issueAccessItem = Issue("ACCESS-RACE", "[Access] Metarace access NFT for Duckracer", 1, 0, false)
    let accessRaceAssetId = issueAccessItem.calculateAssetId().toBase58String()
    let kSpotsBought = keySpotsBought(addressStr)
    [
      issueAccessItem,
      StringEntry("accessItem_" + accessRaceAssetId + "_owner", addressStr),
      StringEntry("address_" + addressStr + "_owning", accessRaceAssetId),
      IntegerEntry(kSpotsBought, tryGetInteger(kSpotsBought) + 1)
    ]
  }
}

@Callable(i)
func lockDuck() = {
  let addressStr = i.caller.toString()
  let pmt = i.payments[0].value()
  let assetId = pmt.assetId.value()
  let assetIssuer = assetInfo(assetId).value().issuer.bytes
  let tDuckDetails = getDuckDetails(assetId)
  let assetColor = tDuckDetails._1
  let isJackpot = tDuckDetails._2
  # let assetRarity = getAssetFarmingPower(assetId)._2

  let kSpotsBusy = keySpotsBusy(addressStr)
  let spotsBusy = tryGetInteger(kSpotsBusy)
  let kSpotsBought = keySpotsBought(addressStr)

  let addressSpotsAvailable = tryGetInteger(kSpotsBought) - spotsBusy

  if (pmt.amount != 1) then throw("NFT is not attached") else 
  if (assetIssuer != getIncubatorAddress() && assetIssuer != getBreederAddress()) then { throw("ivalid NFT attached") } 
  else if (addressSpotsAvailable <= 0) then { throw("No spots available") }
  else {
    let kPerchesAvailable = "address_" + this.toString() + "_perchesAvailable_" + assetColor
    strict perchesAvailable = match getInteger(Address(getFarmingAddress()), kPerchesAvailable) {
      case b:Int => b
      case _ => 0
    }

    let eggAssetId = getEggAssetId()

    strict inv1 = if (perchesAvailable > 0) then { unit } else {
      invoke(Address(getFarmingAddress()), "buyPerch", [assetColor, ""], [AttachedPayment(eggAssetId, 1_0000_0000)])
    }

    strict inv2 = if isJackpot == false then 
      invoke(Address(getFarmingAddress()), "stakeNFT", [], [AttachedPayment(assetId, 1)])  else
      invoke(Address(getFarmingAddress()), "stakeJackpot", [assetColor], [AttachedPayment(assetId, 1)])

    [
      IntegerEntry(kSpotsBusy, spotsBusy + 1),
      StringEntry(keyDuckOwner(assetId), addressStr),
      BooleanEntry(keyLockedDuckStatus(addressStr, assetId.toBase58String()), true),
      IntegerEntry(keyDuckUnlockTime(assetId), lastBlock.timestamp + getMinLockDuration())
    ]
  }
}

@Callable(i)
func unlockDuck(assetIdStr: String) = {
  let addressStr = i.caller.toString()
  let assetId = assetIdStr.fromBase58String()

  let tDuckDetails = getDuckDetails(assetId)
  let assetColor = tDuckDetails._1
  let isJackpot = tDuckDetails._2

  let kSpotsBusy = keySpotsBusy(addressStr)
  let kDuckOwner = keyDuckOwner(assetId)

  let remainingForUnlock = tryGetInteger(keyDuckUnlockTime(assetId)) - lastBlock.timestamp

  if (tryGetString(kDuckOwner) != addressStr) then {throw("The duck is not yours")} 
  else if (remainingForUnlock > 0) then {throw("you need to wait to unlock " + (remainingForUnlock / 1000).toString() + " seconds")}
  else {
    let unstakeFuncName = if isJackpot == true then "unstakeJackpot" else "unstakeNFT" 
    strict inv1 = invoke(Address(getFarmingAddress()), unstakeFuncName, [assetIdStr], [])  # TODO: jackpot unstaking
    [
      ScriptTransfer(i.caller, 1, assetId),
      DeleteEntry(keyLockedDuckStatus(addressStr, assetIdStr)), 
      DeleteEntry(kDuckOwner), 
      IntegerEntry(kSpotsBusy, tryGetInteger(kSpotsBusy) - 1)
    ]
  }
}
        
